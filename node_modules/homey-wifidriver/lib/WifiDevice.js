'use strict';

const Homey = require('homey');
const backoff = require('backoff');

/**
 * The {@link WifiDevice} class handles common functionalities for WiFi-devices in Homey. It exposes methods for handling
 * polling intervals and backoff strategies (basically an advanced setInterval() for retrying certain things).
 *
 * @extends Homey.Device
 * @example
 *
 * const WifiDevice = require('homey-wifidriver').WifiDevice;
 *
 * class myDevice extends WifiDevice {
 *
 *  onInit() {
 *
 *      // Create initialization back off strategy
 *      if(this.backOffStrategy === 'undefined') {
 *          this.createBackOffStrategy({
 *              initialDelay: 10000, // 10 seconds
 *              maxDelay: 1000 * 60 * 60, // 1 hour
 *              maxTries: 10, // Optional, max back off tries, if not provided it will not end until reset
 *              onBackOffReady: this.onInit.bind(this), // Optional, if provided this method will be called on each back off
 *              onBackOffFailed: (() => {}), // Optional, this method will be called when back off failed; maxTries was exceeded
 *          })
 *      }
 *
 *      // Method that will create an interval
 *      this.registerPollInterval({
 *          id: 'status',
 *          fn: this.exampleApiClient.getStatus.bind(this.exampleApiClient),
 *          interval: 30000,
 *      });
 *
 *      // To stop polling
 *      this.deregisterPollInterval('status');
 *
 *      if(initializationSuccess === true) {
 *          this.backOffStrategy.reset()
 *      } else {
 *          this.backOffStrategy.backoff()
 *      }
 *  }
 *
 *  onDeleted() {
 *      // Clean up registered polling intervals
 *      super.onDeleted();
 *  }
 * }
 */
class WifiDevice extends Homey.Device {

	onInit() {
		this.log('init WifiDevice');
		return Promise.resolve();
	}

	/**
	 * Method that creates and returns a back off strategy (Fibonacci).
	 * @param {Object} options - Specification for initialization backoff strategy
	 * @param {Function} options.onBackOffReady - Function will be called on each back off tick
	 * @param {Function} [options.onBackOffFailed] - Function will be called when back off failed (maxTries exceeded)
	 * @param {number} [options.randomisationFactor=0] - Randomize the interval (0 - 1)
	 * @param {number} [options.initialDelay=10000] - After first failed init wait this long (ms)
	 * @param {number} [options.maxDelay=300000] - Max length of time between init retries (ms)
	 * @param {number} [options.maxTries=infinite] - Max number of initialization retries
	 * @returns {Backoff} backOffStrategy - Back off strategy instance
	 */
	createBackOffStrategy(options = {}) {

		// Create back off strategy
		const backOffStrategy = backoff.fibonacci({
			randomisationFactor: options.randomisationFactor || 0,
			initialDelay: options.initialDelay || 10000,
			maxDelay: options.maxDelay || 300000,
		});

		// If provided, set max number of tries
		if (typeof options.maxTries === 'number') {
			backOffStrategy.failAfter(options.maxTries);
		}

		// After back off has been executed, call onBackOffReady() (if provided) or onInit()
		backOffStrategy.on('ready', (number, delay) => {
			this.log(`backOffStrategy tick ${number}, delay is ${delay}`);
			if (typeof options.onBackOffReady === 'function') {
				options.onBackOffReady.call(this);
			} else this.error('backOffStrategy missing onBackOffReady function');
		});

		// If custom onBackOffFailed() method is provided, bind it to the fail event
		if (options.onBackOffFailed) {
			backOffStrategy.on('fail', () => options.onBackOffFailed.call(this));
		} else {
			backOffStrategy.on('fail', () => this.error('onInit() -> backoff strategy failed'));
		}

		return backOffStrategy;
	}

	/**
	 * Method that adds a poll interval to the list, and starts polling on the provided interval.
	 * @param {Object} options
	 * @param {string} options.id - Custom id of poll interval
	 * @param {function} options.fn - Method that will be called when polling
	 * @param {number} options.interval - Time in ms between polling intervals
	 */
	registerPollInterval(options = {}) {
		if (typeof this.pollIntervals === 'undefined') this.pollIntervals = {};
		if (this.pollIntervals.hasOwnProperty(options.id)) this.deregisterPollInterval(options.id);
		this.pollIntervals[options.id] = setInterval(options.fn, options.interval);
		this.log(`registered polling interval (id: ${options.id}, interval: ${options.interval}ms)`);
	}

	/**
	 * Method that clears the poll interval and removes the registered interval from the list.
	 * @param {string} id - poll interval identifier
	 */
	deregisterPollInterval(id) {
		if (typeof this.pollIntervals === 'undefined') return;
		clearInterval(this.pollIntervals[id]);
		delete this.pollIntervals[id];
		this.log(`de-registered polling interval (id: ${id})`);
	}

	/**
	 * This method will be called when the device has been deleted, it makes
	 * sure the client is properly destroyed and left over settings are removed.
	 */
	onDeleted() {
		// Deregister all poll intervals
		Object.keys(this.pollIntervals || {}).forEach(id => this.deregisterPollInterval(id));
	}
}

module.exports = WifiDevice;
