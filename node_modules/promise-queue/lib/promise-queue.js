'use strict';

/**
 * PromiseQueue class, keeps track of a queue containing
 * native Promises. It will process each Promise sequentually, or parallel
 * depending on the concurrency.
 */
class PromiseQueue {

	/**
	 * PromiseQueue constructor
	 * @param options {Object} concurrency (number of parallel requests allowed)
	 */
	constructor(options) {
		options = options || {};
		this._concurrency = options.concurrency || 1;
		this._queue = [];
	}

	/**
	 * PromiseQueue size getter.
	 * @returns {Number}
	 */
	get size() {
		return this._queue.length;
	}

	/**
	 * Add a Promise to the queue, if the queue is empty it will be executed
	 * immediately, else it will wait for the other Promises to complete.
	 * @param fn {Function} Wrapper function which should return a Promise.
	 * @returns {Promise}
	 */
	add(fn, retries) {
		console.log(`add() -> queue size: ${this.size}`);

		return new Promise((resolve, reject) => {

			// Wrapper function which will execute the provided Promise
			const execute = (override) => {
				// If queue needs to be aborted
				if (override) {

					// Return reject
					return reject(override);
				}

				fn()
					.then(result => {
						// Promise has been completed, remove from queue
						this.remove(execute, false);

						// Wait for next tick to execute next Promise
						process.nextTick(this._next.bind(this));
						return resolve(result);
					})
					.catch(err => {
						// Promise has been completed, remove from queue
						this.remove(execute, false);

						// Wait for next tick to execute next Promise
						process.nextTick(this._next.bind(this));
						return reject(err);
					})
			};

			// Push execute function to queue
			this._queue.push(execute);

			// If queue length is less then the allowed concurrency execute
			if (this.size <= this._concurrency) {
				execute();
			}
		})
	}

	/**
	 * Remove a Promise from the PromiseQueue
	 * @param fn {Function} Wrapper function which should return a Promise.
	 */
	remove(fn, reject) {
		console.log(`remove() -> before -> queue size: ${this.size}`);

		// Reject the Promise
		if (typeof reject === 'undefined') fn('removed');

		// Remove Promise from the queue
		this._queue = this._queue.filter(promise => promise !== fn);
		console.log(`remove() -> after -> queue size: ${this.size}`);

	}

	/**
	 * Abort all non-executed Promises in the queue.
	 */
	abort() {
		console.log(`abort() -> before -> queue size: ${this.size}`);
		this._queue.forEach(fn => {
			fn('aborted');
			this.remove(fn);
		})
		console.log(`abort() -> after -> queue size: ${this.size}`);
	}

	/**
	 * Fetch the next Promise in the queue and execute it.
	 * @private
	 */
	_next() {
		console.log(`next() -> queue size: ${this.size}`);
		const execute = this._queue.shift();
		if (typeof execute !== 'undefined') {
			execute.call(this);
		}
	}
}

module.exports = PromiseQueue;