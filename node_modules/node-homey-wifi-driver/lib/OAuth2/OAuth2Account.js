'use strict';

const Homey = require('homey');
const uuid = require('uuid/v4');
const request = require('request-promise-native');
const EventEmitter = require('events');

class OAuth2Account extends EventEmitter {

	constructor(options) {
		super();
		this.oauth2Url = options.url;
		this.tokenEndpoint = options.tokenEndpoint;
		this.key = options.key;
		this.secret = options.secret;
		this.id = options.id || options.oauth2AccountId || uuid();

		console.log('OPTIONS');
		console.log(options);

		if (options.accessToken) Homey.ManagerSettings.set(`oauth2_${this.id}_accessToken`, options.accessToken);
		if (options.refreshToken) Homey.ManagerSettings.set(`oauth2_${this.id}_refreshToken`, options.refreshToken);

		// TODO use random id for storing tokens
		this._accessToken = Homey.ManagerSettings.get(`oauth2_${this.id}_accessToken`) || options.accessToken;
		this._refreshToken = Homey.ManagerSettings.get(`oauth2_${this.id}_refreshToken`) || options.refreshToken;

		console.log('new Account', this);
	}

	getOAuth2Url() {
		return this.oauth2Url;
	}

	destroy() {
		Homey.ManagerSettings.unset(`oauth2_${this.id}_accessToken`);
		Homey.ManagerSettings.unset(`oauth2_${this.id}_refreshToken`);
		this.removeAllListeners();
		// TODO stop refreshing etc
		// TODO unset settings
	}

	get accessToken() {
		return this._accessToken;
	}

	set accessToken(accessToken) {
		console.log('set accesstoken');
		Homey.ManagerSettings.set(`oauth2_${this.id}_accessToken`, accessToken);
		this._accessToken = accessToken;
	}

	get refreshToken() {
		return this._refreshToken;
	}

	set refreshToken(refreshToken) {
		Homey.ManagerSettings.set(`oauth2_${this.id}_refreshToken`, refreshToken);
		this._refreshToken = refreshToken;
	}

	getAccessTokens(code) {
		return new Promise((resolve, reject) => {
			request({
				url: this.tokenEndpoint,
				method: 'POST',
				json: true,
				form: {
					grant_type: 'authorization_code',
					client_id: this.key,
					client_secret: this.secret,
					redirect_uri: 'https://callback.athom.com/oauth2/callback/',
					code,
				},
			}).then(body => {

				// Check for invalid body
				if (!body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.error('error fetching access tokens');
					return reject(new Error('incomplete_tokens_object_retrieved'));
				}

				console.log('fetched new access tokens', body);

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// // Set refresh access token timeout
				this.setRefreshTokenTimeout((body.expires_in - 60) * 1000); // TODO

				// // Emit refreshed event
				this.emit('refreshed', { accessToken: this.accessToken, refreshToken: this.refreshToken });

				// Callback new tokens
				return resolve({
					accessToken: body.access_token,
					refreshToken: body.refresh_token,
				});
			}).catch(err => reject(err));
		});
	}

	/**
	 * Refresh after timeout has expired.
	 * @param timeout
	 */
	setRefreshTokenTimeout(timeout) {
		// Set refresh access token timeout
		if (this.refreshTokensTimeout) clearTimeout(this.refreshTokensTimeout);
		this.refreshTokensTimeout = setTimeout(() => {
			this.refreshAccessTokens();
		}, timeout); // refresh one minute before tokens expire
	}


	refreshAccessTokens() {
		return new Promise((resolve, reject) => {

			if (!this.refreshToken) {
				console.error('no refreshToken provided');
				return reject(new Error('missing_refresh_token'));
			}

			console.log('perform refresh request');

			request({
				url: this.tokenEndpoint,
				method: 'POST',
				headers: {
					'Content-Type': 'application/x-www-form-urlencoded',
				},
				json: true,
				form: {
					client_secret: this.secret,
					client_id: this.key,
					grant_type: 'refresh_token',
					refresh_token: this.refreshToken,
				},
			}).then(body => {

				// Check for invalid body
				if (!body || !body.hasOwnProperty('access_token') || !body.hasOwnProperty('refresh_token')) {
					console.log('error fetching refreshed tokens');
					return reject(new Error('invalid_tokens_object_received'));
				}

				console.log('fetched new access tokens');

				// Store new tokens
				this.accessToken = body.access_token;
				this.refreshToken = body.refresh_token;

				// Set refresh access token timeout
				this.setRefreshTokenTimeout((body.expires_in - 60) * 1000); // TODO

				// Emit refreshed event
				this.emit('refreshed', { accessToken: this.accessToken, refreshToken: this.refreshToken });

				// Callback new tokens
				return resolve({
					accessToken: body.access_token,
					refreshToken: body.refresh_token,
				});

			}).catch(err => {
				console.error(err.stack);
				return reject(err);
			});
		});
	}
}

module.exports = OAuth2Account;
